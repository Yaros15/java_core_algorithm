package service.sort;

import model.Car;

public class SelectionSort implements SortingArray{

    /*
    * Ищем в неотсортированной(правой) части массива, самое маленькое значение,
    * меняем местами текущий элемент массива с минимальным значением в неотсартированой части массива
    */

    @Override
    public Car[] sort(Car[] cars) {

        // В Цикле for перебераем массив -->
        for (int i = 0; i < cars.length; i++){

            int indexNextMinValue = i; // Записываем индекс массива = i, как минимальное значение не отсартированного списка

            // В Цикле for перебераем оставшуюся неотсортированную часть массива -->
            for (int j = (i +1); j < cars.length; j++){
                // сравниваем значени из неотсартированой части массива - с значением расположеном в минимальном индексе -->
                if(cars[j].getReleaseDate() < cars[indexNextMinValue].getReleaseDate()){
                    indexNextMinValue = j; // Перезаписываем индекс минимального значения
                }
                // сравниваем значени из неотсартированой части массива - с значением расположеном в минимальном индексе <--
            }
            // В Цикле for перебераем оставшуюся неотсортированную часть массива <--

            // Текущий индекс массива отличается от индекса с минимальным значением
            if(i != indexNextMinValue){

                // Записываем в временную переменную элемент массива под индексом i
                Car temporaryVariableCar = cars[i];
                // Перезаписываем значение в массиве под индексом i - на значение минимального элемента в неотсортированной части массива
                cars[i] = cars[indexNextMinValue];
                // Перезаписываем значение минимального элемента массива - на значение хранящееся в временной переменной temporaryVariableCar
                cars[indexNextMinValue] = temporaryVariableCar;
            }

        }
        // В Цикле for перебераем массив <--

        return cars; // Возвращаем отсартированый массив
    }
}
