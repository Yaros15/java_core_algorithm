package service.search;

import model.Car;

public class BinarySearch implements SearchArray{

    @Override
    public int search(Car[] cars, int releaseDate) {

        int index = 0;
        int left = 0;   // Устанавливаем левую границу для поиска равную индекс первого элемента массива
        int right = cars.length - 1;    // Устанавливаем правую границу для поиска равную индекс последнего элемента массива
        int middle = 0;     // Инициализируем индекс центрального элемента массива

        // Проверяем первый элемент массива с искомым вариантом -->
        if (releaseDate < cars[left].getReleaseDate()) {
            return left; // возвращаем левую границу
        }
        // Проверяем первый элемент массива с искомым вариантом <--

        // Проверяем последний элемент массива с искомым вариантом -->
        if (releaseDate > cars[right].getReleaseDate()) {
            return right; // возвращаем правую границу
        }
        // Проверяем последний элемент массива с искомым вариантом <--

        // Бежим в цикле пока левый элемент массива меньше/равен правому элементу массива -->
        while (left <= right) {
            // По формуле вычисляем середину массива -->
            middle = (int) ((left + right) / 2);
            // По формуле вычисляем середину массива <--

            // Проверяем центральный элемент массива с искомым вариантом -->
            if (releaseDate == cars[middle].getReleaseDate()) {
                return middle; // Возвращаем индекс центрального элемента
            }
            // Проверяем центральный элемент массива с искомым вариантом <--

            // Проверяем центральный элемент массива меньше ли он искомого варианта -->
            if (releaseDate < cars[middle].getReleaseDate()) {
                right = middle - 1; // Сдвигаем правую границу поиска, на центральный индекс -1, так как центральный элемент уже проверили
            } // Проверяем центральный элемент массива меньше ли он искомого варианта <--
            // Иначе центральный элемент массива больше искомого варианта -->
            else {
                left = middle + 1; // Сдвигаем левую границу поиска, на центральный индекс +1, так как центральный элемент уже проверили
            }
            // Иначе центральный элемент массива больше искомого варианта <--
        }
        // Бежим в цикле пока левый элемент массива меньше/равен правому элементу массива <--

        if (releaseDate < cars[middle].getReleaseDate()) {
            index = middle;
            return index;
        }
        if (releaseDate > cars[middle].getReleaseDate()) {
            index = middle + 1;
            return index;
        }
        return 9999999;
    }
}
